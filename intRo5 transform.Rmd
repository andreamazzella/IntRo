---
title: "5: Transforming data"
subtitle: "Introduction to R for health data"
author: Andrea Mazzella [(GitHub)](https://github.com/andreamazzella)
---

-------------------------------------------------------------------------------

# Content

* Data import/export
 - `.rds`

* Data transformation
 - calculate new variables
 - calculate age
 - categorise continuous variables
 - regroup a categorical variable
 - combine values of two categorical variables
 
-------------------------------------------------------------------------------

# Recap from topic 4

From default dataset `Theoph`, identify at which time point did participant #11 have a plasma theophylline concentration higher than 7.5 mg/L (without scrolling through the dataset manually).



-------------------------------------------------------------------------------

Load packages

```{r}
library(lubridate) # dealing with dates
library(dplyr)     # data management
library(ggplot2)   # graphs
library(forcats)   # dealing with categorical variables
```

-------------------------------------------------------------------------------


# Data import

So far, we've used some sample dataframes that are already loaded in R.

Now let's import an external dataset. The way you do this within `.Rmd` notebooks is:

1. You move your dataset somewhere within the same folder as the `.Rmd` file;
2. You use a function to load the data. There is a different function for each file format: `.csv`, `.xlsx`, `.rds`...
3. You assign the output of this function to a name of your choice.

For example:

1. Make sure that this `.Rmd` file is saved in the same folder as a `data` folder containing `diabetes.rds`, a simulated dataset.
2. Then we use `readRDS()` to load the file (`.rds` is an R native format).

```{r}
# Data import
dm <- readRDS("data/diabetes.rds")
```

(We'll cover other data formats, like Excel or `.csv`, in the next topic).

You will note that now this dataset has been imported in your *Environment*, in the top right of your window.

Let's preview it.

```{r}
head(dm)
```


-------------------------------------------------------------------------------

# Data transformation

During data analysis, it's very common to need to derive new information from the raw data. For example:

* we have date of births, but we don't have ages
* BMI is continuous, but we might want to analyse it divided in clinical categories.
* We have data on disability with three levels: able-bodied, mild disability, severe disability, but we want to change it to a binary variable (disability yes/no).

-------------------------------------------------------------------------------

## Calculate new variables

In `dplyr`, function `mutate()` is used to add new variables (or change existing ones). The first argument is the dataset name, then you have the new variable name, an equals sign, and then the formula to use to calculate the values in the new variable. Formulae can incorporate values from other columns.

As an example, let's convert height from its current unit (cm) into meters.

The following code reads: take dataset "dm", change it by adding a new column called "height_m", and populate its values with the corresponding "heigh" value on the same row, divided by 100.

```{r}
# dplyr
dm |> mutate(height_m = height / 100)
```

This change is temporary; if you want this column to be permanently added to the dataset, you need to assign it.

```{r}
dm <- dm |> mutate(height_m = height / 100)
```

NB: There is no output to this. If you want to check whether it worked, you can have a look at the dataset. By default, new variables are appended at the end.

This can also be done in base R by exposing the variable with `$`, doing the calculation, and assigning it to a new *variable name* (not to the dataset).

```{r}
# Base R
# dm$height_m <- dm$height / 100
```

Whenever you calculate a new variable, I recommend having a quick sanity check to make sure that it did what you intended.

```{r}
# Sanity check
dm |> select(height, height_m)
```


*Exercise 1.*

Convert weight into pounds (1kg = 2.20462 lbs) and add this to the dataset.

(Note: if you make a mistake and you want to recalculate the variable, you don't need to drop the old one first. When you assign it again, R will overwrite the old variable)

```{r new_variable}

```

-------------------------------------------------------------------------------

## Calculate age

Now we can calculate each observation's age at the study start - let's say this is 05 Sep 2022.

Dealing with dates in all programming languages is tricky. We'll come back to this in the next topic; for now, please know that:

* Computers think of dates as *number of days* from a specific time point.
* `lubridate::dmy()` transforms text to an R date.

```{r}
# Create a calculated age variable
dm <- dm |> mutate(
  age = ((dmy("5 Sep 2022") - date_birth) / 365.25) |> as.numeric()
  )

# Sanity check
dm |> select(date_birth, age)
```

*Exercise 2.*

1. Explore the distribution of age with a histogram.
2. What are the median age, Q1 and Q3?

```{r histogram}

```

-------------------------------------------------------------------------------

## Categorise continuous variables

We might also want to transform a continuous variable into a categorical one, for example to reflect clinically meaningful groups.

Imagine we want to categorise BMI into underweight (BMI < 18.5), normal weight (18.5 - 25), overweight (25-30) and obese (>30). Let's see what the minimum and maximum BMI are:

```{r}
summary(dm$bmi)
```

We can then use `mutate()`, this time with helper function `cut()` - we need to specify the `breaks`, i.e., which values delimit groups.

```{r}
dm <- dm |>  mutate(
  bmi_group = cut(bmi, breaks = c(14, 18.5, 25, 30, 37))
  )

# Check that the new variable was created correctly
dm |>
  group_by(bmi_group) |>
  summarise(min(bmi),
            max(bmi),
            n())
```

By default `cut()`:

* creates a left-open and right-closed interval, i.e., (25,30] excludes 25 and include 30.
* creates labels in mathematical notation.

We can add custom labels to each group by adding the argument `labels =`. NB: labels should have 1 fewer element than `breaks =`.

```{r}
dm <- dm |>
  mutate(bmi_group_new = cut(bmi,
                             breaks = c(14, 18.5, 25, 30, 37),
                             labels = c("underweight",
                                        "regular weight",
                                        "overweight",
                                        "obese")))

dm |> count(bmi_group, bmi_group_new)
```

NB: categorising continuous variables, and especially dichotomising them, is potentially highly problematic - see this paper:
Turner E, Dobson J & Pocock S. (2010). [Categorisation of continuous risk factors in epidemiological publications: A survey of current practice](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2972292/).


*Exercise*

Categorise age into groups.
```{r categorise}

```

-------------------------------------------------------------------------------

## Group levels of a categorical variable

```{r}
# TODO: continue from here
```

Sometimes we might need to group together two or more levels of a categorical variables, to avoid data sparsity.

The "disability" variable has only 17 observations in the "severe" level, and only 7 of these have the outcome of interest.

We can group together people with mild and severe disability. We do this with the `mutate()` and `if_else()` functions.

```{r}
# Data exploration
dm |> count(disability, diabetes)

# Regroup
dm <- dm |> mutate(disabled = if_else(disability == "able-bodied", "no", "yes"))

# Check it worked
dm |> count(disability, disabled)
```

In order to categorise into three levels or more, you can either nest one `ifelse()` function into another, or use `case_when()`. `case_when()` takes a condition on the left, then a `~`, then the value to use on the right.

(The `~` sign can be inserted by pressing `Alt 126` in Windows, `Alt 5` with Mac)

For example, the first line of the `mutate()` function reads: create a new variable called "continent_2", and when the value in variable "continent" is "n_america", or when the continent is "s_america", insert the new value "americas".
```{r}
# Explore levels
dm |> count(continent)

# Regroup
dm <- dm |>
  mutate(
    continent_region = case_when(
      continent %in% c("n_america", "s_america") ~ "americas",
      continent %in% c("europe", "asia") ~ "eurasia",
      continent == "africa" ~ "africa",
      continent == "oceania" ~ "oceania"
    ))

# Check it worked
dm |> count(continent, continent_region)
```

There's another way of doing this, if you don't want to keep the original variable â€“ recoding values (we'll explore this in a future topic).

*Exercise*
Create a new variable that indicates whether a patient does any exercise, using `exercise` as reference.
```{r group_levels}

```

-------------------------------------------------------------------------------

## Extra: Combine values of two categorical variables

We can also create a new categorical variables that summarises two other categorical variables.

For example, we can create a new variable, `minority`, that indicates if that person is part of any gender minority.

To do this, we use `mutate()` and `ifelse()` with two "or" statements, indicated by operator `|`. That bit of code means: "if gender is non-binary or trans, assign a value of "nb/trans"; else, assign a value of "cis m/f".
```{r}
# Cross-tabulation
dm |> count(disabled)
dm |> count(bmi_group)

# Create the new variable
dm <- dm |> mutate(obese_disabled = if_else(disabled == "yes" | bmi_group == "obese (>30)",
                                            "yes",
                                            "no"))

# Check it worked
dm |> count(obese_disabled, disabled, bmi_group, useNA = "ifany")
```

-------------------------------------------------------------------------------

# Exporting/saving datasets

Whatever you do to the dataset, it doesn't change the original file. If you want to make some changes permanent, you need to use a writing function. To export in `.rds` format, the function is `saveRDS`.

```{r}
# dm |> saveRDS("data/diabetes_edited.rds")
```

-------------------------------------------------------------------------------

*Recap exercise*
1. Import the `bristol.rds` dataset.
2. Explore the data.
2. Categorise the type of stool in the Bristol scale  into three levels: "constipation" (type 1-2), "normal" (type 3-5), "diarrhoea" (type 6-7).
3. Save a copy as `bristol_v2.rds`.

```{r recap}
# Import


# Explore


# Categorise


# Export


```

-------------------------------------------------------------------------------

## Solutions

```{r solution_recap}
Theoph |> filter(Subject == 11 & conc > 7.5)
```


```{r solution_new_variable}
dm <- dm |> mutate(pounds = weight * 2.20462)
```

```{r solution_histogram}
ggplot(dm, aes(age, fill = gender)) + geom_histogram(bins = 20)
summary(dm$age)
```

```{r solution_categorise}
# Summarise age
summary(dm$age)

# Categorise
dm <- dm |> mutate(
  age_grp = cut(age,
                breaks = c(16, 18, 30, 60, 81),
                labels = c("underage", "young adult", "adult", "older adult"),
                right = FALSE))

# Sanity check
dm |>
  group_by(age_grp) |>
  summarise(min(age),
            max(age),
            n())
```

```{r solution_group_levels}
dm |> count(exercise)

dm <- dm |> mutate(any_exercise = if_else(exercise == "none", "no", "yes"))

dm |> count(exercise, any_exercise)
```

```{r solution_recap}
# Import
bristol <- readRDS("data/bristol.rds")

# Explore
View(bristol)
glimpse(bristol)
count(bristol, bristol_type)

# Categorise
bristol <- bristol |> mutate(
  stool_type = case_when(
    bristol_type <= 2 ~ "constipation",
    bristol_type %in% 3:5 ~ "normal",
    bristol_type >= 6 ~ "diarrhoe
    a"
  ))

bristol |> count(bristol_type, stool_type)

# Export
# bristol |> saveRDS("data/bristol_v2.rds")
```

-------------------------------------------------------------------------------
