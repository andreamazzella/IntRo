---
title: "5: Transforming data"
subtitle: "Introduction to R for health data"
author: Andrea Mazzella [(GitHub)](https://github.com/andreamazzella)
---

NB: work in progress

-------------------------------------------------------------------------------

# Content

* Data import/export
 - `.rds`

* Data transformation
 - calculate new variables
 - calculate age
 - categorise continuous variables
 - regroup a categorical variable
 - combine values of two categorical variables
 
-------------------------------------------------------------------------------

# Recap from topic 4

From default dataset `Theoph`, identify at which time point did participant #11 have a plasma theophylline concentration higher than 7.5 mg/L.

```{r}

```

-------------------------------------------------------------------------------

Load packages

```{r}
library(lubridate) # dealing with dates
library(magrittr)  # %$% pipe
library(dplyr)     # data management
library(ggplot2)   # graphs
library(forcats)   # dealing with categorical variables
```

-------------------------------------------------------------------------------


# Data import

So far, we've used some sample dataframes that are already loaded in R.

Now let's import an external dataset. The way you do this within `.Rmd` notebooks is:

1. You move your dataset somewhere within the same folder as the `.Rmd` file;
2. You use an extension-specific function to load the data;
3. You assign the output of this function to a name of your choice.

For example:

1. Make sure that this `.Rmd` file is saved in the same folder as a `data` folder containing `diabetes.rds`, a simulated dataset.
2. Then we use `readRDS()` to load the file (`.rds` is an R native format).

```{r}
# Data import
dm <- readRDS("data/diabetes.rds")
```

(We'll cover other data extensions, like Excel or `.csv`, in the next topic).

You will note that now this dataset has been imported in your *Environment*, in the top right of your window.

Let's preview it.

```{r}
head(dm)
```


-------------------------------------------------------------------------------

# Data transformation

We might want to transform the data that we have to answer some specific questions. For example, we have date of births, but we don't have ages. BMI is continuous, but we might want to analyse it divided in clinical categories. For some categorical variables, certain strata have very few observations and we might want to group them together. 

## Calculate new variables

Let's start by creating a new variable with a simple calculation: height in metres. There are two ways of doing this; in both you need to assign with `<-` to make the operation permanent.
* In `dplyr`, you use function `mutate()` that is used to change a variable or create a new one, and you assign this new dataset to its own name.
* In base R, you expose the variable with `$`, you do the calculation, and you assign it to a new variable name.

```{r}
# dplyr
dm <- mutate(dm, height_m = height / 100)

# Base R
# dm$height_m <- dm$height / 100
```

NB: There is no output to this. If you want to check whether it worked, you can have a look at the dataset. By default, new variables are appended at the end.


*Exercise 1.*

Convert weight into pounds (1kg = 2.20462 lbs).

(Note for Stata users: if you make a mistake and you want to recalculate the variable, you don't need to drop the old one first. When you assign it again, R will overwrite the old variable)

```{r new_variable}

```


Now let's suppose we want to recalculate the BMI, in order to have decimal figures (our dataset contains BMI as an integer).

```{r}
# Calculate BMI with decimals
dm <- dm |> mutate(bmi_dc = (weight / (height_m)^2))

# Check it worked
dm |> select(bmi, bmi_dc)

# Learn how to delete the old variable in next topic
```


## Calculate age

Now we can calculate each observation's age at the study start - let's say this is 05 Sep 2022.

Dealing with dates in all programming language is tricky, because people write dates in many different formats, with different delimiters between numbers. Package `lubridate` has some good functions to help with dates.

```{r}
# Create a calculated age variable
dm <- dm |> mutate(
  age = (interval(date_birth, dmy("7 May 2020")) / years(1)) |>
        round(1)
  )
```

*Exercise 2.*

Explore the distribution of age with a histogram.

```{r histogram}

```

## Categorise continuous variables

We might also want to transform a continuous variable into a categorical one, for example to reflect clinically meaningful groups. The function we nest in `mutate()` is `cut()`: the `breaks` indicate which values delimit groups, and `labels` indicate how each group be called.

```{r}
dm <- dm |>
  mutate(bmi_group = cut(bmi_dc,
                         breaks = c(0, 18.5, 25, 30,+Inf),
                         labels = c("underwt (<18.5)",
                                    "normal wt (18.5-25)",
                                    "overwt (25-30)",
                                    "obese (>30)")))

# Check that the new variable was created correctly
dm |>
  group_by(bmi_group) |>
  summarise("min BMI" = min(bmi_dc) |> round(1),
            "max BMI" = max(bmi_dc) |> round(1))
```

(NB: categorising continuous variables, and especially dichotomising them, is potentially highly problematic - see this paper:
Turner E, Dobson J & Pocock S. (2010). "Categorisation of continuous risk factors in epidemiological publications: A survey of current practice." Epidemiologic perspectives & innovations).

Now let's use this new categorised BMI for a plot. The ggplot function is `geom_boxplot()`.
```{r}
dm |> filter(exercise_weekly > 0) |> ggplot(aes(exercise_weekly, bmi_group)) + geom_boxplot()
```

We might also want to categorise according to quintiles, and not arbitrary breakpoints. We do this with function `ntile()`.

Let's transform the variable "exercise_weekly", containing minutes of exercise, into quintiles.

```{r}
# Create quintile variable
dm <- dm |> mutate(exer_quint = ntile(exercise_weekly, 5))

# Find the breakpoints
dm |> group_by(exer_quint) |> summarise(max(exercise_weekly))
```

*Exercise*
Categorise height with either `cut()` or `ntile()`.
```{r categorise}

```

## Group levels of a categorical variable

Sometimes we might need to group together two or more levels of a categorical variables, to avoid data sparsity.

The "disability" variable has only 17 observations in the "severe" level, and only 7 of these have the outcome of interest.

We can group together people with mild and severe disability. We do this with the `mutate()` and `if_else()` functions.

```{r}
# Data exploration
dm |> count(disability, diabetes)

# Regroup
dm <- dm |> mutate(disabled = if_else(disability == "able-bodied", "no", "yes"))

# Check it worked
dm |> count(disability, disabled)
```

In order to categorise into three levels or more, you can either nest one `ifelse()` function into another, or use `case_when()`. `case_when()` takes a condition on the left, then a `~`, then the value to use on the right.

(The `~` sign can be inserted by pressing `Alt 126` in Windows, `Alt 5` with Mac)

For example, the first line of the `mutate()` function reads: create a new variable called "continent_2", and when the value in variable "continent" is "n_america", or when the continent is "s_america", insert the new value "americas".
```{r}
# Explore levels
dm |> count(continent)

# Regroup
dm <- dm |>
  mutate(
    continent_region = case_when(
      continent %in% c("n_america", "s_america") ~ "americas",
      continent %in% c("europe", "asia") ~ "eurasia",
      continent == "africa" ~ "africa",
      continent == "oceania" ~ "oceania"
    ))

# Check it worked
dm |> count(continent, continent_region)
```

There's another way of doing this, if you don't want to keep the original variable â€“ recoding values (we'll explore this in a future topic).

*Exercise*
Create a new variable that indicates whether a patient does any exercise, using `exercise` as reference.
```{r group_levels}

```


## Extra: Combine values of two categorical variables

We can also create a new categorical variables that summarises two other categorical variables.

For example, we can create a new variable, `minority`, that indicates if that person is part of any gender minority.

To do this, we use `mutate()` and `ifelse()` with two "or" statements, indicated by operator `|`. That bit of code means: "if gender is non-binary or trans, assign a value of "nb/trans"; else, assign a value of "cis m/f".
```{r}
# Cross-tabulation
dm |> count(disabled)
dm |> count(bmi_group)

# Create the new variable
dm <- dm |> mutate(obese_disabled = if_else(disabled == "yes" | bmi_group == "obese (>30)",
                                            "yes",
                                            "no"))

# Check it worked
dm |> count(obese_disabled, disabled, bmi_group, useNA = "ifany")
```

-------------------------------------------------------------------------------

# Exporting/saving datasets

Whatever you do to the dataset, it doesn't change the original file. If you want to make some changes permanent, you need to use a writing function. To export in `.rds` format, the function is `saveRDS`.

```{r}
# dm |> saveRDS("data/diabetes_edited.rds")
```

-------------------------------------------------------------------------------

*Recap exercise*
1. Import the `bristol.rds` dataset.
2. Explore the data.
2. Categorise the type of stool in the Bristol scale  into three levels: "constipation" (type 1-2), "normal" (type 3-5), "diarrhoea" (type 6-7).
3. Save a copy as `bristol_v2.rds`.

```{r recap}
# Import


# Explore


# Categorise


# Export


```

-------------------------------------------------------------------------------

## Solutions

```{r solution_new_variable}
dm <- dm |> mutate(pounds = weight * 2.20462 |> round(1))
```

```{r solution_histogram}
ggplot(dm, aes(age, fill = gender)) + geom_histogram(bins = 20)
```

```{r solution_categorise}
# Summarise continuous height
summary(dm$height)

# Categorise
dm <- dm |> mutate(height_cat = cut(height,
                                    breaks = c(0, 168.2,+Inf),
                                    labels = c("below avg", "above avg")))

# Explore
dm |> select(height, height_cat)
```

```{r solution_group_levels}
dm |> count(exercise)

dm <- dm |> mutate(any_exercise = if_else(exercise == "none", "no", "yes"))

dm |> count(exercise, any_exercise)
```

```{r solution_recap}
# Import
bristol <- readRDS("data/bristol.rds")

# Explore
View(bristol)
glimpse(bristol)
count(bristol, bristol_type)

# Categorise
bristol <- bristol |> mutate(
  stool_type = case_when(
    bristol_type <= 2 ~ "constipation",
    bristol_type %in% 3:5 ~ "normal",
    bristol_type >= 6 ~ "diarrhoe
    a"
  ))

bristol |> count(bristol_type, stool_type)

# Export
# bristol |> saveRDS("data/bristol_v2.rds")
```

-------------------------------------------------------------------------------
