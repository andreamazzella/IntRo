---
title: "3: Summarising data"
subtitle: "Introduction to R for health data"
author: Andrea Mazzella [(GitHub)](https://github.com/andreamazzella)
editor: visual
---

------------------------------------------------------------------------

# What you will learn

-   Data summarisation
    -   Categorical variables
    -   Continuous variables
    -   Grouped summaries
-   Table 1 with `gtsummary`

------------------------------------------------------------------------

# Recap from topic 03_import

...

------------------------------------------------------------------------

Load packages

https://sfirke.github.io/janitor/index.html

```{r}
library(dplyr)        # count, group_by, summarise
library(ggplot2)
library(janitor)
library(gt)           # gtsave
library(gtsummary)    # tbl_summary, as_gt
```

------------------------------------------------------------------------

For this topic, we'll use `trial`, a sample dataset from package `gtsummary`. This contains the baseline characteristics of 200 patients who received two different cancer drugs (`trt`) and treatment outcomes: `response` and `death`. Check its documentation to learn more.

```{r}
trial <- gtsummary::trial
trial
help(trial)
```

------------------------------------------------------------------------

## Summarising data

### Using `summary()`

You can use `summary()` to get a quick summary of your entire dataset.

*Exercise 1.*

-   Run the following chunk.
-   What is R doing to each variable?
-   What is the median `age`?
-   How many missing values does the `response` variable have?

```{r}
summary(trial)
```

*Want to know more?* This function doesn't provide a helpful summary of character variables, like `trt`. Once you specify the data class, the output will be more telling; see `intRo6 clean.Rmd` for how to do this.

------------------------------------------------------------------------

### `dplyr` basics

We'll frequently use `dplyr` functions, like `summarise()`. They have some things in common:

- Their first argument is always a data frame.
- The following arguments refer to columns by using their names, without quotes
- The output is always a new data frame; the original data frame is left unchanged.

Because the first argument is always the dataframe, we can use @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ the pipe @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

```{r}
# TODO: continue reviewing from here - I want a quick intro to the pipe.

# I've reordered sections so need to reorder exercises as well
# I also need to replace four spaces with two spaces.
```


## Using `summarise()`

We can summarise a data.frame using the `summarise()` function from package `dplyr` and some helper functions like `min()`, `mean()`, `median()`, `sd()`. See `help(summarise)` for a list of helper functions.

For example, to calculate the mean `ttdeath` across every row we can run:

```{r}
trial |> 
  summarise(mean(ttdeath))
```

We can also include more summary metrics in the same `summarise()` call:
```{r}
trial |> 
  summarise(
    n(),
    mean(ttdeath),
    sd(ttdeath)
    )
```

*Exercise 6.*

1.  Try and calculate the average age.
2.  Why do you get an `NA` result?
3.  Use `help(mean)` and see if you can figure out how to calculate the mean age.

```{r}

```

------------------------------------------------------------------------

## Grouped summaries

What if we wanted to calculate the mean age in specific groups of patients, such as by treatment group?

We can use the `summarise()` again, but this time we specify which variable indicates the groups, in the `.by =` argument

```{r}
trial |>
  summarise(
    n(),
    mean(age, na.rm = TRUE),
    .by = trt
    )
```

We can also add a name to the new summary columns:

```{r}
trial |>
  summarise(
      count = n(),
      avg_age = mean(age, na.rm = TRUE),
      avg_follow_up = mean(ttdeath),
      sd_follow_up = sd(ttdeath),
      .by = trt
      )
```

Remember that we can visualise the distribution of a continuous variable across a categorical variable with Box plots:

```{r}
trial |>
  ggplot(aes(age, trt)) +
  geom_boxplot()
```

We can also group by more than one variable.

```{r}
trial |>
  summarise(
      avg_follow_up = mean(ttdeath, na.rm = T) |> round(1),
      .by = c(trt, death)
      )
```

*Exercise 7.*

Calculate the median and maximum marker levels in the four stage groups.

```{r}
# TODO: move
trial |>
    summarise(
        median(marker, na.rm = TRUE),
        max(marker, na.rm = TRUE),
        .by = stage
    )
```

------------------------------------------------------------------------

## Frequency tables

To tabulate categorical data, we have many options, among which:

-   `count()` from `dplyr`
-   `tabyl()` from `janitor`.

*Exercise 2.*

Run these two chunks and compare their outputs.

-   What are the differences?
-   Which function do you prefer?

```{r}
count(trial, response)
```

```{r}
# With percentages
tabyl(trial, response)
```

*Exercise 3.*

1.  Write a line of code that will calculate the percentage of patients with each cancer stage.
2.  Show the same with an appropriate graph.

```{r}
# 1. Frequency table


# 2. Bar plot

```

------------------------------------------------------------------------

## Cross-tabulation

We're often interested in showing the distribution of *two* categorical variables against each other, i.e., cross-tabulation (two-way tables). This way we can check counts and percentages of each possible combination of factors.

To make two-way tables you can use:

-   `count()` from `dplyr`, but it returns an output in long format and without percentages.
-   `tabyl()` and some more functions from `janitor`

```{r}
count(trial, trt, response)

# Just counts
tabyl(trial, trt, response)

tabyl(trial, trt, response) |>
    # Change from counts to row percentages (as proportions)
    adorn_percentages("row") |>
    # Label percentages
    adorn_pct_formatting() |>
    # Add counts back 
    adorn_ns()
```

(Please ignore the `|>` symbol for now; we'll come back to it soon).

*Exercise 4.*

Write some code to calculate the percentage of people who were alive at the end of the study stratified by cancer grade. (If you can't remember the names of your variables, you can run `names(trial)`.

```{r}

```

------------------------------------------------------------------------

## The `|>` pipe

`|>` is called a *pipe*; it's a programming tool that helps improve code readability. It was introduced in R version 4.1.

These two lines are equivalent:

```{r}
trial |> count(response)

count(trial, response)
```

You can see that the pipe is:

1. Taking what's before it
2. Shifting it to the function that follows, as its first argument.

You can also have more than one pipe, as you've seen above. It still works the same, but it makes code much easier to write and read.

```{r}
# This code...
trial |> 
    tabyl(trt, response) |>
    adorn_percentages("row") |>
    adorn_pct_formatting() |>
    adorn_ns()

# ...is equivalent to:
adorn_ns(adorn_pct_formatting(adorn_percentages(tabyl(trial, trt, response), "row")))

# and this
tab_trial <- tabyl(trial, trt, response)
tab_trial_perc <- adorn_percentages(tab_trial, "row")
tab_trial_perc_formt <- adorn_pct_formatting(tab_trial_perc)
adorn_ns(tab_trial_perc_formt)

# Which one would you much rather write? And read?
```

You can set a keyboard shortcut for the `|>` pipe. Go to Tools → Global options → Code → tick "Use native pipe operator". After this, pressing *Ctrl + Shift + M* (on Windows) will insert a `|>` pipe.

*Exercise 5.* Rewrite the following code using the pipe.

```{r}
# Without a pipe
tabyl(trial, trt, response)

# With the pipe

```

Many functions from modern R packages list the data.frame as their first argument. This includes key functions from `ggplot2`, `dplyr`, `janitor`.

```{r}
trial |>
    ggplot(aes(trt, age)) +
    geom_boxplot()
```


------------------------------------------------------------------------


# Summary tables

Summary data is often presented in a "Table 1": this contains a summary of the baseline characteristics, with frequencies and percentages for categorical variables, and means or medians with a measure of variability for continuous variables. Usually these are painful to prepare because you need to do a lot of calculations and then painstakingly copy them into a table. Also, if the data changes (new data, or new variables) you need to redo it from scratch.

Package `gtsummary()` allows us to programmatically create publication-ready summary tables that can be automatically exported into .html or .doc formats.

------------------------------------------------------------------------

## Basic `gtsummary` table

This package is somewhat similar to `ggplot2`. The main function is `tbl_summary()`, which we can then build upon.

By default it summarises *all* dataset variables, but you can `select()` only some.

```{r}
trial |>
  select(trt, age, grade, response) |> 
  tbl_summary()
```

Note that the variables have been renamed, e.g., "Tumor Response" rather than `response`. This is because this dataset is in a special "labelled" format. This won't happen automatically with your data, unless you pre-process it with package `labelled` - by default, the variable names will be displayed in the table.

------------------------------------------------------------------------

## Stratified `gtsummary` table

Using argument `by =` it's possible to stratify the table according to a categorical variable.

For example, let's stratify by treatment arm:

```{r}
trial |>
  select(age, grade, trt, response) |> 
  tbl_summary(by = trt)
```

We might still want to also have a column with overall values. We do this by piping the table into `add_overall()`. Because this will be our final table, we also assign it to a name of our choice.

```{r}
final_table <- trial |>
  select(age, grade, marker, trt, response, death, ttdeath) |> 
  tbl_summary(by = trt) |> 
  add_overall()

final_table
```

*Exercise 8.*

Create a table 1 of the `ToothGrowth` dataset, stratifying by supplement type but keeping an overall column.

```{r}

```

## Save a `gtsummary` table to file

We can use `gtsave()` to save a `gt` table to a file, so we first need to convert our `gtsummary` table into a regular `gt` table using `as_gt()`. Valid extensions include `.pdf`, `.html`, `.png`, `.docx`, `rtf`\`.

NB: This system is not perfect - for example, with .docx and .pdf the formatting might be partially lost in translation.

```{r}
final_table |>
  as_gt() |> 
  gtsave("table1.html")
```

------------------------------------------------------------------------

# Learn more

I recommend these resources:

-   R for Data Science (2ed) chapter 3.5.2: [Data transformation, `summarize`](https://r4ds.hadley.nz/data-transform.html#sec-summarize)
-   `janitor` documentation, [tabyls](https://sfirke.github.io/janitor/articles/tabyls.html)
-   `gtsummary` documentation, [Tutorial: `tbl_summary`](https://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)

------------------------------------------------------------------------

# Solutions

```{r include=FALSE}
# Exercise 3
tabyl(trial, stage)
ggplot(trial, aes(x = stage)) + geom_bar()

# Exercise 4
tabyl(trial, grade, death) |>
    adorn_percentages("row") |>
    adorn_pct_formatting()

# Exercise 6
summarise(trial, mean(age))
summarise(trial, mean(age, na.rm = TRUE))

# Exercise 7
trial |>
  summarise(
      mean_age = mean(age, na.rm = TRUE),
      IQR_age = IQR(age, na.rm = TRUE),
      .by = response
      )

# Exercise 8
teeth <- datasets::ToothGrowth

teeth |> 
  tbl_summary(by = supp) |> 
  add_overall()
```

------------------------------------------------------------------------
